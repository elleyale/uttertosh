<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Nexus Landing Page</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --ai-strip-height: 64px;
      --ai-strip-bg: rgba(3, 5, 16, 0.95);
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
      background: radial-gradient(circle at top, #1a2340, #050608 55%);
      color: #f5f5f5;
      padding-top: var(--ai-strip-height);
    }

    canvas#bg {
      position: fixed;
      inset: 0;
      display: block;
    }

    .ai-strip {
      position: fixed;
      inset: 0 0 auto 0;
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 10px 24px;
      min-height: var(--ai-strip-height);
      background: var(--ai-strip-bg);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 32px rgba(0, 0, 0, 0.45);
      z-index: 3;
      pointer-events: auto;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .ai-strip__label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      white-space: nowrap;
    }

    .ai-strip__label::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #52ffcb;
      box-shadow: 0 0 12px rgba(82, 255, 203, 0.9);
      animation: pulse 1.6s ease-in-out infinite;
    }

    .ai-strip__ticker {
      flex: 1;
      overflow: hidden;
      position: relative;
      pointer-events: none;
    }

    .ticker-track {
      display: flex;
      gap: 32px;
      align-items: center;
      white-space: nowrap;
      animation: ticker 36s linear infinite;
    }

    .ai-strip:hover .ticker-track {
      animation-play-state: paused;
    }

    .ticker-item {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
      letter-spacing: 0.03em;
      padding-right: 32px;
      color: #e4e8ff;
      text-transform: none;
    }

    .ticker-item::before {
      content: attr(data-kind);
      font-size: 11px;
      letter-spacing: 0.08em;
      border-radius: 999px;
      padding: 2px 8px;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
    }

    .ticker-item--news::before {
      background: rgba(79, 195, 247, 0.18);
      color: #53c8ff;
    }

    .ticker-item--quote::before {
      background: rgba(186, 104, 200, 0.22);
      color: #f3a0ff;
    }

    .ai-strip__status {
      font-size: 11px;
      text-transform: none;
      letter-spacing: 0.04em;
      white-space: nowrap;
      opacity: 0.7;
    }

    .ui-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: calc(var(--ai-strip-height) + 16px) 24px 24px 24px;
      z-index: 2;
    }

    .ui-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      max-width: 960px;
    }

    .ui-title {
      pointer-events: auto;
    }

    .ui-title h1 {
      font-size: 32px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .ui-title p {
      opacity: 0.8;
      margin-top: 8px;
      max-width: 420px;
      font-size: 14px;
    }

    .ui-controls {
      pointer-events: auto;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      padding: 8px 16px;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.4);
      color: inherit;
      cursor: pointer;
      backdrop-filter: blur(12px);
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.1s ease;
    }

    button:hover {
      border-color: rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.06);
      transform: translateY(-1px);
    }

    .ui-bottom {
      pointer-events: none;
      font-size: 12px;
      opacity: 0.65;
    }

    .ui-bottom span {
      pointer-events: auto;
    }

    .tooltip {
      position: fixed;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      font-size: 11px;
      pointer-events: none;
      transform: translate(-50%, -150%);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.1s ease;
    }

    @keyframes ticker {
      from {
        transform: translateX(0);
      }
      to {
        transform: translateX(-50%);
      }
    }

    @keyframes pulse {
      0% {
        opacity: 0.4;
        transform: scale(0.9);
      }
      50% {
        opacity: 1;
        transform: scale(1.2);
      }
      100% {
        opacity: 0.4;
        transform: scale(0.9);
      }
    }
  </style>
</head>
<body>
  <div class="ai-strip" aria-live="polite">
    <div class="ai-strip__label">Synth AI • Interactive Tech Scan</div>
    <div class="ai-strip__ticker">
      <div id="ticker-track" class="ticker-track" data-state="boot"></div>
    </div>
    <div class="ai-strip__status" id="ticker-status">Booting agent...</div>
  </div>

  <canvas id="bg"></canvas>

  <div class="ui-overlay">
    <div class="ui-top">
      <div class="ui-title">
        <h1>NEXUS</h1>
        <p>
          Central pod of the experience. Hover and click the modules to explore
          Computer, Scanner, Avatar, and Arcade systems.
        </p>
      </div>

      <div class="ui-controls">
        <button id="toggle-lighting">Toggle Lighting Mode</button>
        <button id="zoom-nexus">Focus Nexus</button>
        <button id="reset-camera">Reset Camera</button>
      </div>
    </div>

    <div class="ui-bottom">
      <span>Tip: drag to orbit, scroll to zoom, right-click to pan.</span>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

    // -------------------------------------------------------------
    // CONFIG
    // -------------------------------------------------------------
    const MODEL_URL =
      "https://raw.githubusercontent.com/elleyale/uttertosh/main/assets/pod1.glb";
    const AI_REFRESH_INTERVAL = 180000; // 3 minutes

    const tickerTrack = document.getElementById("ticker-track");
    const tickerStatus = document.getElementById("ticker-status");

    const quoteLibrary = [
      {
        text: "Interfaces are conversations; make them worthy of attention.",
        source: "Brenda Laurel · Computers as Theatre",
      },
      {
        text: "Interactivity succeeds when it rewards curiosity with clarity.",
        source: "John Maeda · Laws of Simplicity",
      },
      {
        text: "Every pixel a person touches should respond with purpose.",
        source: "Irene Au · Design Better",
      },
      {
        text: "Technology feels alive when feedback arrives at the speed of thought.",
        source: "Bret Victor · Inventing on Principle",
      },
      {
        text: "Play is how humans negotiate the future of interfaces.",
        source: "Katie Salen · Rules of Play",
      },
    ];

    async function fetchInteractiveNews(limit = 6) {
      const endpoint = `https://hn.algolia.com/api/v1/search_by_date?query=interactive%20technology&tags=story&hitsPerPage=${limit}`;
      const response = await fetch(endpoint);

      if (!response.ok) {
        throw new Error(`News request failed with status ${response.status}`);
      }

      const payload = await response.json();
      return (payload.hits || [])
        .map((hit) => {
          const title = hit.title || hit.story_title;
          if (!title) return null;

          const url = hit.url || hit.story_url || "";
          let host = "";

          if (url) {
            try {
              host = new URL(url).hostname.replace(/^www\./, "");
            } catch (err) {
              host = "hn.algolia.com";
            }
          }

          return {
            type: "news",
            text: `${title}${host ? ` · ${host}` : ""}`,
          };
        })
        .filter(Boolean);
    }

    function getQuoteBatch(count = 3) {
      const pool = [...quoteLibrary];
      const picks = [];

      while (pool.length && picks.length < count) {
        const idx = Math.floor(Math.random() * pool.length);
        picks.push(pool.splice(idx, 1)[0]);
      }

      return picks.map((quote) => ({
        type: "quote",
        text: `"${quote.text}" — ${quote.source}`,
      }));
    }

    function renderTickerEntries(entries) {
      if (!tickerTrack) return;
      tickerTrack.innerHTML = "";

      const safeEntries = entries.length
        ? entries
        : [
            {
              type: "news",
              text: "Awaiting live interactive-tech briefs · standby",
            },
          ];

      const duplicated = safeEntries.concat(safeEntries);

      duplicated.forEach((entry) => {
        const span = document.createElement("span");
        span.className = `ticker-item ticker-item--${entry.type}`;
        span.dataset.kind = entry.type === "news" ? "NEWS" : "QUOTE";
        span.textContent = entry.text;
        tickerTrack.appendChild(span);
      });
    }

    async function hydrateTicker() {
      if (!tickerTrack || !tickerStatus) return;
      tickerStatus.textContent = "Synthesizing intel...";

      try {
        const [newsItems, quoteItems] = await Promise.all([
          fetchInteractiveNews(),
          Promise.resolve(getQuoteBatch(3)),
        ]);

        const feed = [...newsItems.slice(0, 5), ...quoteItems];
        renderTickerEntries(feed);
        tickerStatus.textContent = `AI agent live · ${new Date().toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        })}`;
      } catch (error) {
        console.error("Ticker hydration failed:", error);
        renderTickerEntries(getQuoteBatch(4));
        tickerStatus.textContent = "AI agent offline · cached insights";
      }
    }

    hydrateTicker();
    setInterval(hydrateTicker, AI_REFRESH_INTERVAL);

    // -------------------------------------------------------------
    // BASIC THREE SETUP
    // -------------------------------------------------------------
    const canvas = document.getElementById("bg");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050608, 0.15);

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(4.5, 3, 7);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0.75, 0);
    controls.minDistance = 3;
    controls.maxDistance = 12;
    controls.maxPolarAngle = Math.PI * 0.9;

    const idleState = {
      lastInteraction: performance.now(),
      blend: 1,
      threshold: 4000,
    };

    function registerInteraction() {
      idleState.lastInteraction = performance.now();
    }

    controls.addEventListener("start", registerInteraction);
    controls.addEventListener("end", registerInteraction);

    ["pointerdown", "wheel", "touchstart"].forEach((eventName) =>
      window.addEventListener(eventName, registerInteraction, { passive: true })
    );
    window.addEventListener("keydown", registerInteraction);

    // -------------------------------------------------------------
    // LIGHTING (TWO MODES)
    // -------------------------------------------------------------
    const lightingState = { mode: "day" };

    const hemiLight = new THREE.HemisphereLight(0x88aaff, 0x050608, 1.0);
    hemiLight.position.set(0, 4, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.3);
    dirLight.position.set(5, 8, 3);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    scene.add(dirLight);

    const rimLight = new THREE.DirectionalLight(0x66aaff, 0.4);
    rimLight.position.set(-4, 3, -6);
    scene.add(rimLight);

    function applyLightingMode() {
      if (lightingState.mode === "day") {
        hemiLight.intensity = 1.0;
        dirLight.intensity = 1.2;
        rimLight.intensity = 0.4;
        renderer.setClearColor(0x050608, 1);
      } else {
        hemiLight.intensity = 0.3;
        dirLight.intensity = 0.7;
        rimLight.intensity = 0.7;
        renderer.setClearColor(0x020205, 1);
      }
    }
    applyLightingMode();

    // Ground
    const groundGeo = new THREE.CircleGeometry(8, 64);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x06070b,
      roughness: 0.95,
      metalness: 0.1,
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // -------------------------------------------------------------
    // NEXUS GROUP + GLB MODEL
    // -------------------------------------------------------------
    const nexusGroup = new THREE.Group();
    scene.add(nexusGroup);

    // Ring around nexus (simple extra detail)
    const ringGeo = new THREE.TorusGeometry(1.8, 0.04, 16, 80);
    const ringMat = new THREE.MeshStandardMaterial({
      color: 0x7bdcff,
      metalness: 0.8,
      roughness: 0.1,
      emissive: 0x05263a,
      emissiveIntensity: 0.8,
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2;
    ring.castShadow = true;
    nexusGroup.add(ring);

    let nexusCoreObject = null; // will reference the GLB root

    const loader = new GLTFLoader();
    loader.load(
      MODEL_URL,
      (gltf) => {
        const model = gltf.scene;
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;

            // Make sure emissive exists for hover highlight
            if (child.material && !child.material.emissive) {
              child.material.emissive = new THREE.Color(0x000000);
            }
          }
        });

        // Adjust scale / position as needed
        model.scale.set(1.2, 1.2, 1.2);
        model.position.set(0, 0, 0);
        model.rotation.y = Math.PI; // tweak if needed

        model.userData = {
          type: "nexus",
          label: "Nexus Pod",
        };

        nexusGroup.add(model);
        nexusCoreObject = model;
      },
      undefined,
      (err) => {
        console.error("Failed to load pod1.glb:", err);
      }
    );

    // -------------------------------------------------------------
    // NEXUS CHILD MODULES (BOX PLACEHOLDERS)
    // -------------------------------------------------------------
    function createModule(name, color) {
      const geo = new THREE.BoxGeometry(0.5, 0.6, 0.25);
      const mat = new THREE.MeshStandardMaterial({
        color,
        metalness: 0.4,
        roughness: 0.5,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = {
        type: "module",
        label: name,
      };
      return mesh;
    }

    const modules = [];
    const radius = 2.6;
    const moduleY = 0.6;

    const computer = createModule("Computer", 0x4fc3f7);
    computer.position.set(radius, moduleY, 0);
    modules.push(computer);

    const scanner = createModule("Scanner", 0xffb74d);
    scanner.position.set(0, moduleY, radius);
    modules.push(scanner);

    const avatar = createModule("Avatar", 0xba68c8);
    avatar.position.set(-radius, moduleY, 0);
    modules.push(avatar);

    const arcade = createModule("Arcade Machine", 0xef5350);
    arcade.position.set(0, moduleY, -radius);
    modules.push(arcade);

    modules.forEach((m) => {
      m.lookAt(0, moduleY, 0);
      nexusGroup.add(m);
    });

    // -------------------------------------------------------------
    // INTERACTIVITY: RAYCASTING, TOOLTIP, CLICK
    // -------------------------------------------------------------
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const tooltip = document.getElementById("tooltip");
    let hoveredObject = null;

    function onPointerMove(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function onClick() {
      if (!hoveredObject) return;
      const data = hoveredObject.userData || {};

      if (data.type === "module") {
        console.log("Clicked module:", data.label);
        zoomToObject(hoveredObject);
        // TODO: open modal / navigate / trigger action
      } else if (data.type === "nexus") {
        console.log("Clicked Nexus");
        zoomToObject(nexusGroup);
      }
    }

    window.addEventListener("pointermove", onPointerMove);
    window.addEventListener("click", onClick);

    // -------------------------------------------------------------
    // CAMERA FOCUS HELPERS
    // -------------------------------------------------------------
    let cameraLerp = null;

    function startCameraLerp(targetPosition, targetLookAt, duration = 0.9) {
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const startTime = performance.now();
      cameraLerp = {
        startPos,
        startTarget,
        endPos: targetPosition.clone(),
        endTarget: targetLookAt.clone(),
        duration,
        startTime,
      };
    }

    function zoomToObject(object3d) {
      const box = new THREE.Box3().setFromObject(object3d);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = maxDim * 2.5 || 4;

      const dir = new THREE.Vector3(0, 0.3, 1).normalize();
      const targetPos = center.clone().add(dir.multiplyScalar(distance));

      startCameraLerp(targetPos, center);
    }

    function resetCamera() {
      startCameraLerp(
        new THREE.Vector3(4.5, 3, 7),
        new THREE.Vector3(0, 0.75, 0)
      );
    }

    document
      .getElementById("reset-camera")
      .addEventListener("click", resetCamera);

    document
      .getElementById("zoom-nexus")
      .addEventListener("click", () => zoomToObject(nexusGroup));

    document
      .getElementById("toggle-lighting")
      .addEventListener("click", () => {
        lightingState.mode = lightingState.mode === "day" ? "night" : "day";
        applyLightingMode();
      });

    // -------------------------------------------------------------
    // ANIMATION LOOP
    // -------------------------------------------------------------
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const t = clock.elapsedTime;

      const idle =
        performance.now() - idleState.lastInteraction > idleState.threshold;
      idleState.blend = THREE.MathUtils.damp(
        idleState.blend,
        idle ? 1 : 0,
        3,
        delta
      );

      const bounceOffset = Math.sin(t * 2.0) * 0.15 * idleState.blend;
      nexusGroup.position.y = 0.5 + bounceOffset;
      ring.rotation.z += 0.003 * (0.6 + 0.4 * idleState.blend);

      modules.forEach((m, i) => {
        const moduleBounce = Math.sin(t * 2 + i) * 0.08 * idleState.blend;
        m.position.y = moduleY + moduleBounce;
      });

      // Hover / raycast
      raycaster.setFromCamera(pointer, camera);
      const pickables = [
        ...(nexusCoreObject ? [nexusCoreObject] : []),
        ...modules,
      ];

      const intersects = raycaster.intersectObjects(pickables, true);

      if (intersects.length > 0) {
        const hit = findTopLevelMesh(intersects[0].object);

        if (hoveredObject !== hit) {
          clearHover();
          hoveredObject = hit;
          applyHover(hoveredObject);
        }
      } else {
        clearHover();
        hoveredObject = null;
        tooltip.style.opacity = 0;
      }

      // Tooltip follow
      if (hoveredObject && hoveredObject.userData && hoveredObject.userData.label) {
        tooltip.textContent = hoveredObject.userData.label;
        tooltip.style.left = `${(pointer.x * 0.5 + 0.5) * window.innerWidth}px`;
        tooltip.style.top = `${(-pointer.y * 0.5 + 0.5) * window.innerHeight}px`;
        tooltip.style.opacity = 1;
      }

      // Camera lerp
      if (cameraLerp) {
        const now = performance.now();
        const elapsed = (now - cameraLerp.startTime) / 1000;
        const tNorm = Math.min(elapsed / cameraLerp.duration, 1);
        const tSmooth = tNorm * tNorm * (3 - 2 * tNorm);

        camera.position.lerpVectors(
          cameraLerp.startPos,
          cameraLerp.endPos,
          tSmooth
        );
        controls.target.lerpVectors(
          cameraLerp.startTarget,
          cameraLerp.endTarget,
          tSmooth
        );

        if (tNorm >= 1) cameraLerp = null;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    function findTopLevelMesh(obj) {
      // For glTF, intersected object might be a child; climb up until we
      // find something with userData.type or hit the root.
      let cur = obj;
      while (cur.parent && !cur.userData.type) {
        cur = cur.parent;
      }
      return cur;
    }

    function applyHover(obj) {
      if (!obj || !obj.material) return;

      obj.scale.set(1.05, 1.05, 1.05);

      if (Array.isArray(obj.material)) {
        obj.material.forEach((m) => {
          if (!m.emissive) return;
          if (m.userData?._baseEmissive === undefined) {
            m.userData = m.userData || {};
            m.userData._baseEmissive = m.emissive.getHex();
          }
          m.emissive.setHex(0xffffff);
        });
      } else {
        const m = obj.material;
        if (m.emissive) {
          if (m.userData?._baseEmissive === undefined) {
            m.userData = m.userData || {};
            m.userData._baseEmissive = m.emissive.getHex();
          }
          m.emissive.setHex(0xffffff);
        }
      }
    }

    function clearHover() {
      if (!hoveredObject || !hoveredObject.material) return;

      hoveredObject.scale.set(1, 1, 1);

      if (Array.isArray(hoveredObject.material)) {
        hoveredObject.material.forEach((m) => {
          if (!m.emissive) return;
          const base =
            (m.userData && m.userData._baseEmissive) !== undefined
              ? m.userData._baseEmissive
              : 0x000000;
          m.emissive.setHex(base);
        });
      } else {
        const m = hoveredObject.material;
        if (m.emissive) {
          const base =
            (m.userData && m.userData._baseEmissive) !== undefined
              ? m.userData._baseEmissive
              : 0x000000;
          m.emissive.setHex(base);
        }
      }
    }

    animate();

    // -------------------------------------------------------------
    // RESIZE
    // -------------------------------------------------------------
    window.addEventListener("resize", () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });
  </script>
</body>
</html>
