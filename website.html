<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Nexus Landing Page</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
      background: radial-gradient(circle at top, #1a2340, #050608 55%);
      color: #f5f5f5;
    }

    canvas#bg {
      position: fixed;
      inset: 0;
      display: block;
    }

    .ui-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 24px;
    }

    .ui-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      max-width: 960px;
    }

    .ui-title {
      pointer-events: auto;
    }

    .ui-title h1 {
      font-size: 32px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .ui-title p {
      opacity: 0.8;
      margin-top: 8px;
      max-width: 420px;
      font-size: 14px;
    }

    .ui-controls {
      pointer-events: auto;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      padding: 8px 16px;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.4);
      color: inherit;
      cursor: pointer;
      backdrop-filter: blur(12px);
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.1s ease;
    }

    button:hover {
      border-color: rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.06);
      transform: translateY(-1px);
    }

    .ui-bottom {
      pointer-events: none;
      font-size: 12px;
      opacity: 0.65;
    }

    .ui-bottom span {
      pointer-events: auto;
    }

    .tooltip {
      position: fixed;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      font-size: 11px;
      pointer-events: none;
      transform: translate(-50%, -150%);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.1s ease;
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <div class="ui-overlay">
    <div class="ui-top">
      <div class="ui-title">
        <h1>NEXUS</h1>
        <p>
          Central pod of the experience. Hover and click the modules to explore
          Computer, Scanner, Avatar, and Arcade systems.
        </p>
      </div>

      <div class="ui-controls">
        <button id="toggle-lighting">Toggle Lighting Mode</button>
        <button id="zoom-nexus">Focus Nexus</button>
        <button id="reset-camera">Reset Camera</button>
      </div>
    </div>

    <div class="ui-bottom">
      <span>Tip: drag to orbit, scroll to zoom, right-click to pan.</span>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

    // -------------------------------------------------------------
    // CONFIG
    // -------------------------------------------------------------
    const MODEL_URL =
      "https://raw.githubusercontent.com/elleyale/uttertosh/main/assets/pod1.glb";

    // -------------------------------------------------------------
    // BASIC THREE SETUP
    // -------------------------------------------------------------
    const canvas = document.getElementById("bg");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050608, 0.15);

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(4.5, 3, 7);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0.75, 0);
    controls.minDistance = 3;
    controls.maxDistance = 12;
    controls.maxPolarAngle = Math.PI * 0.9;

    // -------------------------------------------------------------
    // LIGHTING (TWO MODES)
    // -------------------------------------------------------------
    const lightingState = { mode: "day" };

    const hemiLight = new THREE.HemisphereLight(0x88aaff, 0x050608, 1.0);
    hemiLight.position.set(0, 4, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.3);
    dirLight.position.set(5, 8, 3);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    scene.add(dirLight);

    const rimLight = new THREE.DirectionalLight(0x66aaff, 0.4);
    rimLight.position.set(-4, 3, -6);
    scene.add(rimLight);

    function applyLightingMode() {
      if (lightingState.mode === "day") {
        hemiLight.intensity = 1.0;
        dirLight.intensity = 1.2;
        rimLight.intensity = 0.4;
        renderer.setClearColor(0x050608, 1);
      } else {
        hemiLight.intensity = 0.3;
        dirLight.intensity = 0.7;
        rimLight.intensity = 0.7;
        renderer.setClearColor(0x020205, 1);
      }
    }
    applyLightingMode();

    // Ground
    const groundGeo = new THREE.CircleGeometry(8, 64);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x06070b,
      roughness: 0.95,
      metalness: 0.1,
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // -------------------------------------------------------------
    // NEXUS GROUP + GLB MODEL
    // -------------------------------------------------------------
    const nexusGroup = new THREE.Group();
    scene.add(nexusGroup);

    // Ring around nexus (simple extra detail)
    const ringGeo = new THREE.TorusGeometry(1.8, 0.04, 16, 80);
    const ringMat = new THREE.MeshStandardMaterial({
      color: 0x7bdcff,
      metalness: 0.8,
      roughness: 0.1,
      emissive: 0x05263a,
      emissiveIntensity: 0.8,
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2;
    ring.castShadow = true;
    nexusGroup.add(ring);

    let nexusCoreObject = null; // will reference the GLB root

    const loader = new GLTFLoader();
    loader.load(
      MODEL_URL,
      (gltf) => {
        const model = gltf.scene;
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;

            // Make sure emissive exists for hover highlight
            if (child.material && !child.material.emissive) {
              child.material.emissive = new THREE.Color(0x000000);
            }
          }
        });

        // Adjust scale / position as needed
        model.scale.set(1.2, 1.2, 1.2);
        model.position.set(0, 0, 0);
        model.rotation.y = Math.PI; // tweak if needed

        model.userData = {
          type: "nexus",
          label: "Nexus Pod",
        };

        nexusGroup.add(model);
        nexusCoreObject = model;
      },
      undefined,
      (err) => {
        console.error("Failed to load pod1.glb:", err);
      }
    );

    // -------------------------------------------------------------
    // NEXUS CHILD MODULES (BOX PLACEHOLDERS)
    // -------------------------------------------------------------
    function createModule(name, color) {
      const geo = new THREE.BoxGeometry(0.5, 0.6, 0.25);
      const mat = new THREE.MeshStandardMaterial({
        color,
        metalness: 0.4,
        roughness: 0.5,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = {
        type: "module",
        label: name,
      };
      return mesh;
    }

    const modules = [];
    const radius = 2.6;
    const moduleY = 0.6;

    const computer = createModule("Computer", 0x4fc3f7);
    computer.position.set(radius, moduleY, 0);
    modules.push(computer);

    const scanner = createModule("Scanner", 0xffb74d);
    scanner.position.set(0, moduleY, radius);
    modules.push(scanner);

    const avatar = createModule("Avatar", 0xba68c8);
    avatar.position.set(-radius, moduleY, 0);
    modules.push(avatar);

    const arcade = createModule("Arcade Machine", 0xef5350);
    arcade.position.set(0, moduleY, -radius);
    modules.push(arcade);

    modules.forEach((m) => {
      m.lookAt(0, moduleY, 0);
      nexusGroup.add(m);
    });

    // -------------------------------------------------------------
    // INTERACTIVITY: RAYCASTING, TOOLTIP, CLICK
    // -------------------------------------------------------------
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const tooltip = document.getElementById("tooltip");
    let hoveredObject = null;

    function onPointerMove(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function onClick() {
      if (!hoveredObject) return;
      const data = hoveredObject.userData || {};

      if (data.type === "module") {
        console.log("Clicked module:", data.label);
        zoomToObject(hoveredObject);
        // TODO: open modal / navigate / trigger action
      } else if (data.type === "nexus") {
        console.log("Clicked Nexus");
        zoomToObject(nexusGroup);
      }
    }

    window.addEventListener("pointermove", onPointerMove);
    window.addEventListener("click", onClick);

    // -------------------------------------------------------------
    // CAMERA FOCUS HELPERS
    // -------------------------------------------------------------
    let cameraLerp = null;

    function startCameraLerp(targetPosition, targetLookAt, duration = 0.9) {
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const startTime = performance.now();
      cameraLerp = {
        startPos,
        startTarget,
        endPos: targetPosition.clone(),
        endTarget: targetLookAt.clone(),
        duration,
        startTime,
      };
    }

    function zoomToObject(object3d) {
      const box = new THREE.Box3().setFromObject(object3d);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = maxDim * 2.5 || 4;

      const dir = new THREE.Vector3(0, 0.3, 1).normalize();
      const targetPos = center.clone().add(dir.multiplyScalar(distance));

      startCameraLerp(targetPos, center);
    }

    function resetCamera() {
      startCameraLerp(
        new THREE.Vector3(4.5, 3, 7),
        new THREE.Vector3(0, 0.75, 0)
      );
    }

    document
      .getElementById("reset-camera")
      .addEventListener("click", resetCamera);

    document
      .getElementById("zoom-nexus")
      .addEventListener("click", () => zoomToObject(nexusGroup));

    document
      .getElementById("toggle-lighting")
      .addEventListener("click", () => {
        lightingState.mode = lightingState.mode === "day" ? "night" : "day";
        applyLightingMode();
      });

    // -------------------------------------------------------------
    // ANIMATION LOOP
    // -------------------------------------------------------------
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const t = clock.getElapsedTime();

      // Bouncy Nexus
      nexusGroup.position.y = Math.sin(t * 2.0) * 0.15 + 0.5;
      ring.rotation.z += 0.003;

      modules.forEach((m, i) => {
        m.position.y = moduleY + Math.sin(t * 2 + i) * 0.08;
      });

      // Hover / raycast
      raycaster.setFromCamera(pointer, camera);
      const pickables = [
        ...(nexusCoreObject ? [nexusCoreObject] : []),
        ...modules,
      ];

      const intersects = raycaster.intersectObjects(pickables, true);

      if (intersects.length > 0) {
        const hit = findTopLevelMesh(intersects[0].object);

        if (hoveredObject !== hit) {
          clearHover();
          hoveredObject = hit;
          applyHover(hoveredObject);
        }
      } else {
        clearHover();
        hoveredObject = null;
        tooltip.style.opacity = 0;
      }

      // Tooltip follow
      if (hoveredObject && hoveredObject.userData && hoveredObject.userData.label) {
        tooltip.textContent = hoveredObject.userData.label;
        tooltip.style.left = `${(pointer.x * 0.5 + 0.5) * window.innerWidth}px`;
        tooltip.style.top = `${(-pointer.y * 0.5 + 0.5) * window.innerHeight}px`;
        tooltip.style.opacity = 1;
      }

      // Camera lerp
      if (cameraLerp) {
        const now = performance.now();
        const elapsed = (now - cameraLerp.startTime) / 1000;
        const tNorm = Math.min(elapsed / cameraLerp.duration, 1);
        const tSmooth = tNorm * tNorm * (3 - 2 * tNorm);

        camera.position.lerpVectors(
          cameraLerp.startPos,
          cameraLerp.endPos,
          tSmooth
        );
        controls.target.lerpVectors(
          cameraLerp.startTarget,
          cameraLerp.endTarget,
          tSmooth
        );

        if (tNorm >= 1) cameraLerp = null;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    function findTopLevelMesh(obj) {
      // For glTF, intersected object might be a child; climb up until we
      // find something with userData.type or hit the root.
      let cur = obj;
      while (cur.parent && !cur.userData.type) {
        cur = cur.parent;
      }
      return cur;
    }

    function applyHover(obj) {
      if (!obj || !obj.material) return;

      obj.scale.set(1.05, 1.05, 1.05);

      if (Array.isArray(obj.material)) {
        obj.material.forEach((m) => {
          if (!m.emissive) return;
          if (m.userData?._baseEmissive === undefined) {
            m.userData = m.userData || {};
            m.userData._baseEmissive = m.emissive.getHex();
          }
          m.emissive.setHex(0xffffff);
        });
      } else {
        const m = obj.material;
        if (m.emissive) {
          if (m.userData?._baseEmissive === undefined) {
            m.userData = m.userData || {};
            m.userData._baseEmissive = m.emissive.getHex();
          }
          m.emissive.setHex(0xffffff);
        }
      }
    }

    function clearHover() {
      if (!hoveredObject || !hoveredObject.material) return;

      hoveredObject.scale.set(1, 1, 1);

      if (Array.isArray(hoveredObject.material)) {
        hoveredObject.material.forEach((m) => {
          if (!m.emissive) return;
          const base =
            (m.userData && m.userData._baseEmissive) !== undefined
              ? m.userData._baseEmissive
              : 0x000000;
          m.emissive.setHex(base);
        });
      } else {
        const m = hoveredObject.material;
        if (m.emissive) {
          const base =
            (m.userData && m.userData._baseEmissive) !== undefined
              ? m.userData._baseEmissive
              : 0x000000;
          m.emissive.setHex(base);
        }
      }
    }

    animate();

    // -------------------------------------------------------------
    // RESIZE
    // -------------------------------------------------------------
    window.addEventListener("resize", () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });
  </script>
</body>
</html>
